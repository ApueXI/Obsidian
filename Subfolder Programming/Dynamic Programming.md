## Dynamic Programming

## 🛠 **1. Prerequisites**

Before DP, make sure you know:

✅ **Basic programming** (loops, recursion, arrays)

✅ **Time complexity & Big-O notation**

✅ **Greedy algorithms & recursion**

✅ **Math fundamentals** (combinatorics, modular arithmetic for some DP)

---

## 🐣 **2. DP Fundamentals (Beginner)**

Here you learn **what DP is** and how to identify DP problems.

- ✅ What is DP? (overlapping subproblems & optimal substructure)
- ✅ **Top-down vs Bottom-up** (Memoization vs Tabulation)
- ✅ Recurrence relations
- ✅ Simple examples:
    - Fibonacci numbers
    - Factorial with memoization
    - Climbing stairs problem
    - Minimum steps to reach n

---

## 🧩 **3. 1D DP Problems (Easy → Medium)**

Learn problems where the **state depends on 1 variable**.

- ✅ Fibonacci variations
- ✅ Min cost climbing stairs
- ✅ Coin change (ways & min coins)
- ✅ Longest increasing subsequence (LIS)
- ✅ Maximum sum subarray (Kadane’s algorithm – DP variant)

---

## 🔄 **4. 2D DP Problems (Medium → Hard)**

Now states depend on **two variables**, often grids or strings.

- ✅ Grid problems (unique paths, min path sum)
- ✅ Longest Common Subsequence (LCS)
- ✅ Longest Common Substring
- ✅ Edit Distance (Levenshtein) → used in search/autocorrect
- ✅ Matrix Chain Multiplication

---

## 🎒 **5. Classic Optimization Problems**

These teach **knapsack-like thinking**.

- ✅ 0/1 Knapsack problem
- ✅ Subset sum & partition problems
- ✅ Rod cutting problem
- ✅ Unbounded knapsack
- ✅ Minimum subset difference

---

## 📜 **6. Sequence & String DP**

More advanced string/sequence problems.

- ✅ Palindrome partitioning
- ✅ Longest Palindromic Subsequence
- ✅ Count palindromic substrings
- ✅ Regular expression matching DP
- ✅ Wildcard matching

---

## 🌐 **7. DP on Graphs & Trees**

When DP meets graph theory.

- ✅ Shortest paths (Floyd-Warshall, Bellman-Ford)
- ✅ DP on trees (e.g., subtree sums, tree diameter)
- ✅ Bitmask DP for Traveling Salesman Problem (TSP)
- ✅ DAG longest path problems

---

## 🤯 **8. Advanced DP Patterns**

These are **hardcore** DP techniques.

- ✅ Bitmask DP (used in combinatorial problems)
- ✅ Digit DP (counting numbers with constraints)
- ✅ State Compression DP
- ✅ Divide & Conquer DP
- ✅ DP with segment trees or Fenwick trees
- ✅ Probability & Expected Value DP

---

## 🚀 **9. DP in Real-World & Web Context**

Finally, see how DP appears in **real-world applications**.

- ✅ Levenshtein distance for search/autocorrect
- ✅ Sequence alignment (bioinformatics)
- ✅ Dynamic pricing & recommendation engines
- ✅ AI game algorithms
- ✅ Caching/memoization in frontend & backend

---

## 🔁 **10. Practice & Patterns**

To truly master DP, you need **pattern recognition**. Practice problems like:

- “DP on grids”
- “DP on strings”
- “Knapsack patterns”
- “Digit DP”

Websites like **LeetCode (Medium/Hard), Codeforces, AtCoder** have tons of DP problems.

---

### 🗺️ **Quick Roadmap Visual**

1️⃣ **Basics:** Recursion → Memoization → Tabulation

2️⃣ **1D DP:** Fibonacci, Coin Change

3️⃣ **2D DP:** LCS, Grid problems

4️⃣ **Knapsack patterns:** 0/1, unbounded, subsets

5️⃣ **String DP:** Palindromes, Edit Distance

6️⃣ **Graph DP:** Floyd-Warshall, TSP

7️⃣ **Advanced DP:** Bitmask, Digit DP, State compression

8️⃣ **Applications:** Real-world & web usage
